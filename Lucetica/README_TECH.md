# README_TECH.md (Lucetica)

## 0. プロジェクト概要と操作説明

本ドキュメントは、3Dアクションゲーム『Lucetica』の**技術的な詳細と、私の担当範囲における設計意図**を解説します。

| 項目 | 説明 |
| :--- | :--- |
| **ゲーム概要** | 3種の武器（大剣、弓、杖）を切り替えながらボスを攻略する3Dアクションゲームプロトタイプ。 |
| **クリア条件** | ボスの撃破。 |
| **担当コードの場所** | `/Lucetica/Assets/Scripts/teru/script/` 以下。 |
| **特に見てほしいコード** | **`EStateMachine.cs`** (拡張性の高いステートマシンの基盤クラス) |

### 基本操作（Xboxコントローラー）

| 操作 | ボタン | 説明 |
| :--- | :--- | :--- |
| **移動** | Lスティック | プレイヤーの移動 |
| **視点移動** | Rスティック | カメラの視点操作 |
| **ダッシュ** | A | 回避および高速移動 |
| **通常攻撃** | X | 装備中の武器で通常攻撃 |
| **必殺技** | X 長押し | 装備中の武器で必殺技を発動 |
| **武器切り替え** | Y | 武器を切り替える（大剣/弓/杖の順） |

---

## 1. プロジェクト目的と設計思想

### 1-1. ステートマシン導入の背景

敵キャラクターの行動制御を担当するにあたり、アニメーション、攻撃処理、状態変化など、複雑なロジックの**見通しと保守性**を確保するため、**ステートマシンパターン**を採用しました。これにより、一つの状態に集中してロジックを記述でき、デバッグの容易性を実現しました。

### 1-2. 拡張性を持たせた設計（`EStateMachine.cs`）

特に、本システムが敵キャラクターだけでなく、**今後追加されるプレイヤーやNPCなどの行動制御にも再利用できる**よう、ステートマシンを汎用的な基盤として設計しました。

* **ジェネリクスによる汎用化:** クラスを `EStateMachine<TOwner>` とジェネリクス化することで、特定の型に依存せず、多様なオブジェクト（`Enemy` や `Player` など）に流用可能な構造を実現しました。
* **シンプルな状態管理:** 各ステート内で次の状態を判断し、遷移を呼び出す方式を採用。新しい行動は**新しいステートクラスを追加するだけ**で拡張でき、既存コードへの影響を最小限に抑えています。

---

## 2. 技術的アピール：ステートマシン実装の詳細

### 2-1. コア設計と機能

| 実装要素 | `EStateMachine.cs` の役割 | アピールできる点 |
| :--- | :--- | :--- |
| **オーナーの安全な参照** | `StateBase` のプロパティを通じて、各ステートが**型付き**でオーナーオブジェクト（敵本体）にアクセスできる設計。 | **型安全性の確保**。キャストエラーを排除し、コードの堅牢性を高めています。 |
| **ライフサイクル管理** | `ChangeState` メソッドで、古いステートの **`OnEnd()`** と新しいステートの **`OnStart()`** の呼び出しを厳格に制御。 | **堅牢な状態管理**。クリーンアップと初期化の処理漏れを防ぎ、メモリリークや状態の競合を防ぎます。 |
| **ステートの登録** | `Add<T>(int stateId)` メソッドにより、ステートのインスタンスを辞書 (`_states`) に事前登録。 | **パフォーマンス安定化**。ランタイムでインスタンス生成が不要となり、ステート切り替えの速度を安定させています。 |

### 2-2. 責務の分離

敵キャラクターのコードは、ステートマシンを生成し、フレームごとに駆動する**「仲介役」**に徹しています。これにより、以下のように責務を明確に分離しました。

* **`EStateMachine`**: 状態の保持と遷移ルールの管理。
* **敵のステートクラス**: その状態（例: `AttackState`）における具体的な行動ロジックのみを記述。

---

## 3. 開発における課題と解決プロセス

### 3-1. ステートマシン実装の安定化

本プロジェクトで最も深く学習し、時間を費やした点は、**ステート設計の安定化**でした。

#### 課題と直面した問題

抽象的なステートマシンの基礎設計を完了した後の、具体的なロジック組み込み段階で、**フレーム間の状態競合**や**参照の初期化不足による Null Reference**が頻発しました。特に、高速な連続アクション時に、ステートの `OnEnd()` と `OnStart()` の呼び出し順序やタイミングが原因で、アニメーションがフリーズする問題に直面しました。

#### 解決プロセスと学んだ点

この問題に対し、設計理論の調査だけでなく、デバッグログやブレークポイントを用いた**地道な実動作のトレース**を徹底しました。

最終的に、`ChangeState` メソッド内で、ステート遷移処理を**絶対に中断されないアトミックな処理**として実行するよう見直しました。この経験を通じ、抽象的な設計理論と、Unityのフレームワーク内での**実運用時のライフサイクル管理**の重要性を深く学び、**粘り強くバグを解決する能力**を身につけることができました。
